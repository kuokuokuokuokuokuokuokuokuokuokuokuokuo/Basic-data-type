java 内存
  栈 : 一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配 。
       定义变量 堆中对象的引用
      回收 : 当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。
       
  堆 : 堆内存用于存放由new创建的对象和数组
  回收 :java虚拟机自动垃圾回收器来管理
  
  在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，
  在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，
  引用变量相当于为数组或者对象起的一个别名，或者代号。
  
  数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。
  这个也是java比较占内存的主要原因.
  实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!
  
  java中内存分配策略及堆和栈的比较 

　　1 内存分配策略
    按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的. 
    
    静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.
    这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,
    也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. 
   
     栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,
     程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,
     必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 

　　 静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,
    而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.
    堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. 
